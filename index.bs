<pre class=metadata>
Title: Multi-Screen Window Placement
Shortname: multi-screen
Abstract: This document defines a web platform API that allows script to query the device for information about connected displays, and additional APIs to position windows relative to those displays.
Status: CG-DRAFT
URL: https://webscreens.github.io/window-placement
Level: 1
Editor: Victor Costan, Google Inc. https://google.com, costan@google.com
Editor: Joshua Bell, Google Inc. https://google.com, jsbell@google.com
Repository: webscreens/window-placement
Group: secondscreencg
Test Suite: https://github.com/web-platform-tests/wpt/tree/master/screen_enumeration
Logo: logo.svg
Favicon: logo.svg
Complain About: accidental-2119 yes, missing-example-ids yes
Markup Shorthands: css no, markdown yes
Assume Explicit For: yes
</pre>

<style>
.domintro::before {
    content: 'For web developers (non-normative)';
    text-transform: initial;
}
.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
.domintro dt a {
    color: inherit; border-bottom-style: none;
}
.domintro dt code {
    font-size: inherit;
}
</style>

<pre class=anchors>
spec: pointerevents; urlPrefix: https://www.w3.org/TR/pointerevents/
    type: dfn; text: pointer; url: dfn-pointer
spec: css-values-4; urlPrefix: https://drafts.csswg.org/css-values-4/
    type: dfn; text: CSS pixel; url: px
spec: fingerprinting-guidance; urlPrefix: https://www.w3.org/TR/fingerprinting-guidance/
    type: dfn; text: passive fingerprinting; url: dfn-passive-fingerprinting
    type: dfn; text: active fingerprinting; url: dfn-active-fingerprinting
    type: dfn; text: cookie-like fingerprinting; url: dfn-cookie-like-fingerprinting
</pre>

<!-- ====================================================================== -->
# Introduction # {#introduction}
<!-- ====================================================================== -->

*This section is non-normative.*

Operating systems generally allow users to connect multiple screens to a single device and arrange them virtually to extend the overall visual workspace.

As multi-screen devices and applications become a more common and critical part of user experiences, it becomes more important to give developers information and tools to leverage that expanded visual environment.

Issue: More in this section?

<!-- ====================================================================== -->
## Motivating Use Cases ## {#motivations}
<!-- ====================================================================== -->

The aim of this specification is enable better experiences for web application users with multiple screens. Here are some use cases that inform the design:

* Slideshow app presents on a projector, shows speaker notes on a laptop screen.
* Financial app opens a dashboard of windows across multiple monitors.
* Medical app opens images (e.g. x-rays) on a high-resolution grayscale display.
* Creativity app shows secondary windows (e.g. palette) on a separate screen.
* Conference room app shows controls on a touch screen device and video on a TV.
* Multi-screen layouts in gaming, signage, artistic, and other types of apps.
* Site optimizes content and layout when a window spans multiple screens.


<!-- ====================================================================== -->
## Usage Overview ## {#usage-overview}
<!-- ====================================================================== -->

Issue: Write this section, using examples from Explainer:

* Show elements fullscreen on a specific screen
* Place web app windows on a specific screen

<!-- ====================================================================== -->
### Detecting when screen properties change ### {#usage-overview-property-changes}
<!-- ====================================================================== -->

Without even considering multiple screens, sites may want to adapt to screen attribute changes. To avoid polling, `change` events are fired at the {{Screen}} object:

```js
screen.addEventListener('change') e => {
  /* display properties have changed for the current screen */
});
```


<!-- ====================================================================== -->
### Detecting the presence of extended screen areas ### {#usage-overview-extended}
<!-- ====================================================================== -->

The most basic question developers may ask to support multi-screen devices is: "Does this device have multiple screens that may be used for window placement?" This is provided by the {{Screen/isExtended}} boolean, exposed to secure contexts without a permission prompt.

```js
if (screen.isExtended) {
  /* enable multi-screen options */
}
```

<!-- ====================================================================== -->
### Requesting extended screen information ### {#usage-overview-screen-information}
<!-- ====================================================================== -->

After determining that there are multiple screens, information can be requested about them using the {{Window/getScreens()}} method. This method may prompt the user for permission. The resulting object lets developers enumerate screens, inspect screen properties, and watch for changes.

```js
try {
  const screensInfo = await window.getScreens();

  // Do something with the screens right now.
  processScreens(screensInfo);

  // And also if the screens change in the future.
  screensInfo.onscreenschange = e => {
    processScreens(screensInfo);
  };
} catch (ex) {
  /* permission denied, or other error */
}

function processScreens(screensInfo) {
  // Build a UI listing screens.
  clearScreenList();
  screensInfo.screens.forEach(screen => {
    addToScreenList({id: screen.id, name: screen.label, screen: screen});
  });

  // Set the selection to the current screen.
  selectCurrentInScreenList(screensInfo.currentScreen.id);
}
```


<!-- ====================================================================== -->
### Showing elements fullscreen on a specific screen ### {#usage-overview-fullscreen-on-specific-screen}
<!-- ====================================================================== -->

A common use case is to present a slideshow or other media fullscreen on a particular screen, while showing controls for the content on another screen. Once a screen has been selected, either interactively, using the screen's properties, or remembering a previous selection, it can be passed to the {{Element/requestFullscreen()}} method.


```js
// Call an assumed helper function which asynchronously selects
// a screen, and returns a ScreenAdvanced instance.
const screenAdvanced = await getScreenForSlideshow();

// Request that a particular element go fullscreen on the selected
// screen.
slideshowElement.requestFullscreen({ screen: screenAdvanced });
```

<!-- ====================================================================== -->
### Placing windows on a specific screen ### {#usage-overview-place-windows-on-specific-screen}
<!-- ====================================================================== -->

Windows can be placed on specific screens using the coordinates provided in the {{ScreenAdvanced}} interface.

```js
function openAndCenterWindow(url, screenAdvanced, width, height) {

  // Compute coordinates relative to the target screen's coordinates.
  const left = Math.round(screenAdvanced.width  - width) / 2;
  const top = Math.round(screenAdvanced.height - height) / 2;

  // Open the window with the requested dimensions.
  return window.open(url, '_blank', `left=${left},top=${top},width=${width},height=${height}`);
}
```

<!-- ====================================================================== -->
# Concepts # {#concepts}
<!-- ====================================================================== -->

Issue: Finish up this section.

<!-- ====================================================================== -->
## Screen pixel ## {#concept-screen-pixel}
<!-- ====================================================================== -->

A <dfn>screen pixel</dfn> is the smallest component of a screen that can be programmed directly.
A screen pixel shows one color.

Note: On a liquid-crystal display (LCD), each screen pixel is made up of three components.
  Each component is a (red, green, blue) light with variable intensity.
  Reasoning about pixel components (subpixel rendering) is out of scope for this specification.

A [=/screen pixel=]'s <dfn>color depth</dfn> is the number of bits used to represent the color displayed by that pixel.

Note:
  Some popular rendering systems model [=screen pixels=] as having a [=/color
  depth=] of 24. The 24 bits are separated into 3 groups of 8 bits used to
  represent the intensity of the (red, green, blue) subpixels of an LCD
  [=screen pixel=].

<!-- ====================================================================== -->
## Screen area ## {#concept-screen-area}
<!-- ====================================================================== -->

A <dfn>screen area</dfn> is a rectangular two-dimensional grid of [=/screen pixels=] with the same [=/color depth=].

<div dfn-for="screen area">

A [=/screen area=] has a <dfn>width</dfn>, which is the number of [=/screen pixels=] along the main dimension of the [=/screen area=]'s rectangular pixel grid.

A [=/screen area=] has a <dfn>height</dfn>, which is the number of [=/screen pixels=] along the secondary dimension of the [=/screen area=]'s rectangular pixel grid.

</div>

Note:
  The grid size is usually expressed as [=screen area/width=] x [=screen area/height=].
  For example, a 1920x1080 screen area has a grid with a [=screen area/width=] of 1920 pixels and a [=screen area/height=] of 1080 pixels.

<!-- ====================================================================== -->
## Connected screen ## {#concept-connected-screen}
<!-- ====================================================================== -->

The computer system hosting the user agent presents information using one or more <dfn>connected screens</dfn>.

A computer system's [=/connected screens=] may change while a user agent is running.

<div dfn-for="connected screen">

A [=/connected screen=] has a <dfn>screen area</dfn> (a [=/screen area=]), which is used to present information to the user.

A [=/connected screen=] has a <dfn>color depth</dfn>, which is the [=/color depth=] of the screen's pixels.

<div algorithm>

A [=/connected screen=]'s <dfn>device pixel ratio</dfn> is the result of this algorithm:

1. Let |CSS pixel size| be the size of a [=/CSS pixel=].

1. Let |device pixel size| be the vertical size of a [=/screen pixel=].

1. Return the result of dividing |CSS pixel size| by |device pixel size|.

</div>

A [=/connected screen=] has an <dfn>orientation</dfn>, which is described in [[screen-orientation]].

A [=/connected screen=] has a <dfn>label</dfn>, which is a string that meaningfully describes the screen to a user.

Note: The [=connected screen/label=] can be an arbitrary string selected by the user agent. It could describe the screen relative to the device, e.g. `"internal"` vs. `"external"`, it could include the dimensions, e.g. `"640x480"`, it could include a distinguishing number, e.g. `"screen 1"` vs. `"screen 2"`, or all of the preceeding.

Advisement: While many properties of screens could be used for [=/active fingerprinting=], the strings used as [=connected screen/labels=] in particular should be considered carefully to minimize the uniqueness. For example, it would be a poor choice to include the serial number of the device.

A [=/connected screen=] has an <dfn>id</dfn>, which is a string that uniquely identifies the screen to a web application.

</div>

Advisement: To prevent the [=connected screen/id=] being used to correlate users across sites ([=/active fingerprinting=]), the [=connected screen/id=] assigned to a screen should be unique to each site. To prevent the [=connected screen/id=] being used as a form of persistent re-identifier ([=/cookie-like fingerprinting=]), a new [=connected screen/id=] should be assigned to a screen after storage is cleared for the site.


<!-- ====================================================================== -->
### Available screen area ### {#concept-available-screen-area}
<!-- ====================================================================== -->

Web applications cannot assume that a [=/connected screen=]'s [=/screen area=] is entirely available to them.
The operating system hosting the user agent may reserve some of the [=/screen area=] for its own user interface, and the user agent's chrome may be taking some of the [=/screen area=].

<div dfn-for="connected screen">

The <dfn>available screen area</dfn> of a [=/connected screen=] is a subset of the [=/screen area=] that is entirely available for web applications.
The rectangle's edges are parallel to the [=/screen area=] edges.

The <dfn>available width</dfn> of a [=/connected screen=] is the [=screen area/width=] of the [=/connected screen=]'s [=connected screen/available screen area=].

The <dfn>available height</dfn> of a [=/connected screen=] is the [=screen area/height=] of the [=/connected screen=]'s [=connected screen/available screen area=].

</div>

Issue: Are these definitions actually needed? Reference [[CSSOM-VIEW#web-exposed-screen-information]] if so.


<!-- ====================================================================== -->
### Pointer type support ### {#concept-pointer-type-support}
<!-- ====================================================================== -->

Users often interact with content on [=/connected screens=] using a [=/pointer=], an input device that can target coordinates on the screen. Examples include mouse, pen, or touch contact. [[PointerEvents]]

The <dfn for="connected screen">supported pointer types</dfn> for a [=/connected screen=] is the [=/ordered set=] of possible {{PointerEvent/pointerType}} values that can appear in {{PointerEvent}}s fired for content on the screen. The set is ordered by [=list/sorting in ascending order=] with the [=/code unit less than=] algorithm.

Note:
  As an example, the [=connected screen/supported pointer types=] for a device supporting both mouse and touch input would be « `"mouse"`, `"touch"` ».


<!-- ====================================================================== -->
### Screen position ### {#concept-screen-position}
<!-- ====================================================================== -->

A computer system has a <dfn>virtual screen area</dfn>, with x- and y-coordinates that increase rightwards and downwards, respectively. Every [=/connected screen=]'s [=/screen area=] is a view onto a rectangular subset of the [=/virtual screen area=].

A [=/connected screen=] has a <dfn for="connected screen">screen position</dfn> which is the x- and y-coordinates in the [=/virtual screen area=] of the top left corner the rectangular subset it is a view onto, in pixels. Coordinates may be negative, and are typically expressed as (<var ignore>x</var>, <var ignore>y</var>).


<!-- ====================================================================== -->
### Observable properties ### {#concept-observable-properties}
<!-- ====================================================================== -->

The <dfn for="connected screen">basic observable properties</dfn> of a [=/connected screen=] are:

* The width and height of the [=connected screen/screen area=]
* The width and height of the [=connected screen/available screen area=]
* [=connected screen/color depth=]

The <dfn for="connected screen">advanced observable properties</dfn> of a [=/connected screen=] are:

* [=connected screen/screen position=]
* [=connected screen/screen area=]
* [=connected screen/available screen area=]
* [=connected screen/color depth=]
* [=connected screen/device pixel ratio=]
* [=connected screen/orientation=]
* [=connected screen/label=]
* [=connected screen/supported pointer types=]


<!-- ====================================================================== -->
## Primary screen ## {#concept-primary-screen}
<!-- ====================================================================== -->

The computer system hosting the user agent has exactly one <dfn>primary</dfn> [=/connected screen=]. All the other [=connected screens|connected screen=] are considered <dfn>secondary</dfn>.

Note:
  The primary connected screen typically hosts the operating system's user interface for task management, such as the Windows task bar and the macOS Dock.

A [=/connected screen=]'s designation as [=primary=] or [=secondary=] may change while the user agent is running.

The <dfn>primary screen</dfn> is the [=/connected screen=] that is currently [=/primary=].

Note:
  Most operating systems let the user choose the primary connected screen using a management user interface, such as the Windows Control Panel and the macOS Preferences application.

By convention, the [=/primary screen=]'s [=connected screen/screen position=] is (0,0).

Note:
  As an example, consider a computer system with three 1920x1080 screens arranged horizontally. If the middle screen is the [=/primary screen=], then the left screen's [=connected screen/screen position=] (-1920,0). The middle screen's [=connected screen/screen position=] (0,0). The right screen's [=connected screen/screen position=] is (3840,0).



<!-- ====================================================================== -->
## Internal screen ## {#concept-internal-screen}
<!-- ====================================================================== -->

Each [=/connected screen=] may be designated as <dfn>internal</dfn> or <dfn>external</dfn>.

[=External=] screens are manufactured separately from the computer systems they are connected to.
It is not unusual for an [=external=] screen to be disconnected from one computer system and connected to a different computer system.

[=Internal=] screens are usually attached to a computer system at manufacturing time.
[=Internal=] screens and are not intended to be detached by users.
However, [=internal=] [=/connected screens=] may still appear and disappear while the user agent is running.

Note:
  A laptop has an [=internal=] screen and an input device.
  A laptop might be used while opened, with its [=internal=] screen powered on.
  However, a laptop might also be used while closed, where its [=internal=] screen is powered off.

  A laptop might be opened and closed while a user agent is running.
  In this case, the [=internal=] screen appears as a [=/connected screen=] when the laptop is opened.
  The [=internal=] [=/connected screen=] disappears when the laptop is closed.


<!-- ====================================================================== -->
## Current screen ## {#concept-current-screen}
<!-- ====================================================================== -->

Scripts executing in a {{Window}} context can access the {{Window/screen}} property. This {{Screen}} object reflects the properties of the <dfn>current screen</dfn>, which is a [=/connected screen=] that presents the window.

Note: On many operating systems, a window can be presented across multiple screens with different properties, or can be in a "hidden" state and not presented on any screen. Operating systems and user agents are assumed to define a canonical screen for a given {{Window}}, for example the screen with the largest intersection area with the window.


<!-- ====================================================================== -->
# API # {#api}
<!-- ====================================================================== -->

<!-- ====================================================================== -->
## Extensions to the {{Screen}} interface ## {#api-extensions-to-screen}
<!-- ====================================================================== -->

<div class="domintro note">

    : window . screen . {{Screen/isExtended}}

    :: Returns `true` if the device's display is extended across multiple screens.

</div>

<xmp class=idl>
partial interface Screen /* : EventTarget */ {
  [SecureContext]
  readonly attribute boolean isExtended;

  [SecureContext]
  attribute EventHandler onchange;
};
</xmp>

Issue: {{Screen}} needs to derived from {{EventTarget}}. This will require changes to [[CSSOM-VIEW#the-screen-interface]].

<div algorithm>

The <dfn attribute for=Screen>isExtended</dfn> getter steps are:

1. Return true if the computer system has more than one [=/connected screen=], and false otherwise.

</div>

<!-- ====================================================================== -->
### {{Screen}} events ### {#api-screen-events}
<!-- ====================================================================== -->

The <dfn attribute for=Screen>onchange</dfn> attribute is an [=/event handler IDL attribute=] whose [=/event handler event type=] is <a event for=Screen>`change`</a>.

When any [=connected screen/basic observable property=] of a {{Window}}'s [=/current screen=] changes, [=/fire an event=] with type <dfn event for=Screen>`change`</dfn> at the {{Window}}'s associated {{Screen}} object.


<!-- ====================================================================== -->
## Extensions to the {{Window}} interface ## {#api-extensions-to-window}
<!-- ====================================================================== -->

<div class="domintro note">

    : await window . {{Window/getScreens()}}

    :: Returns a promise that fulfills with a {{Screens}} object with information about all connected screens. The promise will be rejected if permission is denied.

</div>

<xmp class=idl>
partial interface Window {
  [SecureContext]
  Promise<Screens> getScreens();
};
</xmp>

Each {{Window}} object has an associated {{Screens}} object.

Each {{Window}} object also has an associated {{ScreenAdvanced}} object which reflects the properties of the window's [=/current screen=].

<div algorithm>

The <dfn method for=Window>getScreens()</dfn> method steps are:

1. Let |promise| be [=/a new promise=].

1. Run the following steps [=/in parallel=]:

    1. Let |permissionState| be the result of [=/requesting permission to use=] the [=/powerful feature=] named `"window-placement"`.

    1. If |permissionState| is `"denied"` then [=/reject=] |promise| with a {{"NotAllowedError"}} {{DOMException}} and abort these steps.

    1. [=/Resolve=] |promise| with [=/this=]'s associated {{Screens}} object.

1. Return |promise|.

</div>

In addition to the partial interface additions defined above, the {{Window}} interface described in [[CSSOM-VIEW#extensions-to-the-window-interface]] are modified:

* The {{Window/screenX}} and {{Window/screenLeft}} attributes must return the x-coordinate, relative to the top left corner of the [=/primary screen=]'s Web-exposed screen area, of the left of the client window as number of [=/CSS pixels=], or zero if there is no such thing.
* The {{Window/screenY}} and {{Window/screenTop}} attributes must return the y-coordinate, relative to the top left corner of the of the [=/primary screen=]'s Web-exposed screen area, of the top of the client window as number of [=/CSS pixels=], or zero if there is no such thing.
* The {{Window/moveTo()}} steps move the target window relative to the top left corner of the [=/primary screen=]'s Web-exposed screen area.
* Handling of `"left"` and `"top"` for {{Window/open(url, name, features)|open()}} move the target window relative to the top or left edge (respectively) of the [=/primary screen=]'s Web-exposed screen area.

Issue: Merge the above with [[CSSOM-VIEW#extensions-to-the-window-interface]].

<!-- ====================================================================== -->
## The {{Screens}} interface ## {#api-screens-interface}
<!-- ====================================================================== -->


<div class="domintro note">

    : <var ignore>screens</var> . {{Screens/screens}}
    :: Returns an array of {{ScreenAdvanced}} objects that describe each of the connected screens.

    : <var ignore>screens</var> . {{Screens/currentScreen}}
    :: Returns a {{ScreenAdvanced}} object that describes the current screen. This object describes the same object that the {{Window/screen}} property of {{Window}} describes, but provides a superset of the information.

</div>

<xmp class=idl>
[Exposed=Window, SecureContext]
interface Screens {
  readonly attribute FrozenArray<ScreenAdvanced> screens;

  readonly attribute ScreenAdvanced currentScreen;

  attribute EventHandler onscreenschange;
  attribute EventHandler oncurrentscreenchange;
};
</xmp>

<div algorithm>

The <dfn attribute for=Screens>screens</dfn> getter steps are:

1. Let |screens| be a new [=/list=].

1. For each |screen| of [=/connected screens=]:

    1. Let |a| be the {{ScreenAdvanced}} object describing |screen|.

    1. [=list/Append=] |a| to |screens|.

1. Return the result of [=list/sorting=] |screens| in ascending order with the [=/screen ordering=] algorithm.

</div>


<div algorithm>

The <dfn>screen ordering</dfn> algorithm defines a [=/connected screen=] |a| as less than a [=/connected screen=] |b| if the following steps return true:

1. If |a|'s [=connected screen/screen position=] y-coordinate is less than |b|'s [=connected screen/screen position=] y-coordinate, then return true.
1. If |b|'s [=connected screen/screen position=] y-coordinate is less than |a|'s [=connected screen/screen position=] y-coordinate, then return false.
1. If |a|'s [=connected screen/screen position=] x-coordinate is less than |b|'s [=connected screen/screen position=] x-coordinate, then return true.
1. If |b|'s [=connected screen/screen position=] x-coordinate is less than |a|'s [=connected screen/screen position=] x-coordinate, then return false.
1. Return whether or not |a|'s [=connected screen/id=] is [=/code unit less than=] |b|'s [=connected screen/id=].

</div>

Issue: Should x or y have sort priority? Fall back to id?

The <dfn attribute for=Screens>currentScreens</dfn> getter steps are to return the {{ScreenAdvanced}} object associated with the {{Window}} associated with [=/this=].


<!-- ====================================================================== -->
### {{Screens}} events ### {#api-screens-events}
<!-- ====================================================================== -->

The <dfn attribute for=Screens>onscreenschange</dfn> attribute is an [=/event handler IDL attribute=] whose [=/event handler event type=] is <a event for=Screens>`screenschange`</a>.

The <dfn attribute for=Screens>oncurrentscreenchange</dfn> attribute is an [=/event handler IDL attribute=] whose [=/event handler event type=] is <a event for=Screens>`currentscreenchange`</a>.

When the set of [=/connected screens=] changes, [=/fire an event=] with type <dfn event for=Screens>`screenschange`</dfn> at every {{Screens}} object.

When the [=/current screen=] of a {{Window}} changes from one [=/connected screen=] to another (e.g. the {{Window}} has been moved to a different display), [=/fire an event=] with type <dfn event for=Screens>`currentscreenchange`</dfn> at the {{Window}}'s associated {{Screens}} object.


<!-- ====================================================================== -->
## The {{ScreenAdvanced}} interface ## {#api-screenadvanced-interface}
<!-- ====================================================================== -->

A {{ScreenAdvanced}} object represents a [=/connected screen=].

<div class="domintro note">

  : |screen| . {{ScreenAdvanced/left}}
  :: Returns the distance from the left edge of the primary screen to the left edge of the screen area.

  : |screen| . {{ScreenAdvanced/top}}
  :: Returns the distance from the top edge of the primary screen to the top edge of the screen area.

  : |screen| . {{ScreenAdvanced/isPrimary}}
  :: Returns whether this screen is designated as the 'primary' screen by the OS (otherwise it is a 'secondary' screen).

  : |screen| . {{ScreenAdvanced/isInternal}}
  :: Returns whether this screen is an 'internal' panel built into the device, like a laptop display (otherwise it is 'external', like a wired monitor).

  : |screen| . {{ScreenAdvanced/devicePixelRatio}}
  :: Returns the ratio between physical and logical pixels.

  : |screen| . {{ScreenAdvanced/id}}
  :: Returns a temporary generated per-origin unique ID; reset when cookies are deleted.

  : |screen| . {{ScreenAdvanced/pointerTypes}}
  :: Returns an array of pointer types supported by the screen, e.g. `"mouse"`, `"touch"`, or `"pen"`.

  : |screen| . {{ScreenAdvanced/label}}
  :: A user-friendly label for the screen, determined by the user agent and OS.

</div>

<xmp class=idl>
[SecureContext] interface ScreenAdvanced : Screen {
  readonly attribute long left;
  readonly attribute long top;
  readonly attribute boolean isPrimary;
  readonly attribute boolean isInternal;
  readonly attribute float devicePixelRatio;
  readonly attribute DOMString id;
  readonly attribute FrozenArray<DOMString> pointerTypes;
  readonly attribute DOMString label;
};
</xmp>


The <dfn attribute for=ScreenAdvanced>left</dfn> getter steps to return [=/this=]'s [=connected screen/screen position=]'s x-coordinate.

The <dfn attribute for=ScreenAdvanced>top</dfn> getter steps to return [=/this=]'s [=connected screen/screen position=]'s y-coordinate.

The <dfn attribute for=ScreenAdvanced>isPrimary</dfn> getter steps are to return true if [=/this=] is the [=/primary screen=], or false otherwise.

The <dfn attribute for=ScreenAdvanced>isInternal</dfn> getter steps are to return true if [=/this=] is [=/internal=], or false otherwise.

The <dfn attribute for=ScreenAdvanced>devicePixelRatio</dfn> getter steps are to return [=/this=]'s [=connected screen/device pixel ratio=].

The <dfn attribute for=ScreenAdvanced>id</dfn> getter steps are to return [=/this=]'s [=connected screen/id=].

The <dfn attribute for=ScreenAdvanced>pointerTypes</dfn> getter steps are to return [=/this=]'s [=connected screen/supported pointer types=].

The <dfn attribute for=ScreenAdvanced>label</dfn> getter steps are to return [=/this=]'s [=connected screen/label=].


<!-- ====================================================================== -->
### {{ScreenAdvanced}} events ### {#api-screenadvanced-events}
<!-- ====================================================================== -->

When any [=connected screen/basic observable property=] or [=connected screen/advanced observable property=] of a {{ScreenAdvanced}}'s associated [=/connected screen=] changes, [=/fire an event=] with type <dfn event for=ScreenAdvanced>`change`</dfn> at the {{ScreenAdvanced}} object.


<!-- ====================================================================== -->
## Extensions to {{FullscreenOptions}} ## {#api-extensions-to-fullscreen-options}
<!-- ====================================================================== -->

<xmp class=idl>
partial dictionary FullscreenOptions {
  // An optional way to request a specific screen for element fullscreen.
  ScreenAdvanced screen;
};
</xmp>

Issue: Write me.


<!-- ====================================================================== -->
## Permissions ## {#api-permissions}
<!-- ====================================================================== -->

The <dfn for=PermissionName enum-value>"window-placement"</dfn> [=/powerful feature=] is a [=/boolean feature=].

Issue(54): Call it `"multiscreen"` instead?

Issue: File bug against [[permissions]], to add to the registry.

Issue: Talk about permissions policy integration.


<!-- ====================================================================== -->
# Security Considerations # {#security}
<!-- ====================================================================== -->

Issue: Write this section.


<!-- ====================================================================== -->
# Privacy Considerations # {#privacy}
<!-- ====================================================================== -->

Issue: Write this section.


<!-- ====================================================================== -->
# Accessibility Considerations # {#a11y}
<!-- ====================================================================== -->

Issue: Write this section.


<!-- ====================================================================== -->
# Internationalization Considerations # {#i18n}
<!-- ====================================================================== -->

Issue: Write this section.


<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Many thanks to

Anssi Kostiainen,
Chris Terefinko,
Domenic Denicola,
Jonathan Garbee,
Kenneth Rohde Christiansen,
L. David Baron,
Lukasz Olejnik,
Marijn Kruisselbrink,
Matt Giuca,
Michael Ketting,
Michael Wasserman,
Nadav Sinai,
Peter Linss,
Staphany Park,
Theresa O'Connor,
Thomas Nattestad,
Thomas Steiner,

for helping craft this specification.

Issue: Ensure we didn't forget anyone!

Special thanks to Tab Atkins, Jr. for creating and maintaining [Bikeshed](https://github.com/tabatkins/bikeshed), the specification authoring tool used to create this document, and for his general authoring advice.
